<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>418 You're a Teapot</title>
    <link rel="icon" href="data:,">
    <style>
        /* Prevent horizontal overflow on small screens and make sizing consistent */
        *, *::before, *::after { box-sizing: border-box; }

        body {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
            background: transparent;
            /* allow vertical scrolling but prevent horizontal overflow */
            overflow-x: hidden;
            color: #333;
            padding-top: 50vh; /* move card down by a quarter of viewport */
        }
        /* Canvas as full-screen background */
        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            background: none;
            pointer-events: none; /* Don't block clicks on UI */
        }
        /* Cloud layer between background and card */
        #cloud-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 5; /* Above canvas, below card */
            pointer-events: none;
        }
        .cloud {
            position: absolute;
            opacity: 0.9;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.12));
            will-change: transform;
            user-select: none;
        }
        .plane {
            position: absolute;
            opacity: 1;
            filter: drop-shadow(0 3px 3px rgba(0,0,0,0.18));
            will-change: transform;
            user-select: none;
            pointer-events: none;
        }
        .main-text {
            font-size: 48px;
        }
        .sub-text {
            font-size: 24px;
            margin-top: 10px;
        }
        /* Foreground content container */
        .content-card {
            position: relative;
            z-index: 10;
            background: rgba(255, 255, 255, 0.85);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 24px 28px;
            text-align: center;
            line-height: 1.2;
            width: min(92vw, 560px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            text-align: center;
        }
        /* Primary button spans full card */
        .grass-button {
            margin-top: 20px;
            padding: 12px 18px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            width: 100%;
            display: block;
        }
        /* Row below: two buttons side-by-side, symmetrical */
        .button-row-secondary {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 12px;
            width: 100%;
            align-items: stretch; /* make both cells equal height */
        }
        /* Mobile-friendly content card and typography */
        @media (max-width: 480px) {
            .content-card { padding: 16px 16px; max-height: 72vh; overflow-y: auto; }
            .main-text { font-size: 32px; }
            .sub-text { font-size: 18px; }
            .counter-text { font-size: 15px; }
            .grass-button, .brag-button { font-size: 15px; padding: 10px 14px; }
        }
        /* Fine-tune on small screens */
        @media (max-width: 480px) {
            .button-row-secondary { gap: 10px; }
        }
        /* Add pointing finger emojis to grass button */
        .grass-button::before,
        .grass-button::after {
            content: "ðŸ‘‰";
            display: inline-block;
            margin: 0 8px;
        }
        .grass-button::after {
            content: "ðŸ‘ˆ";
        }
        .grass-button:hover {
            background-color: #45a049;
        }
        .counter-text {
            font-size: 18px;
            margin-top: 10px;
        }
        /* X brag button styling */
        .brag-button {
            box-sizing: border-box;
            display: flex;            /* center content for symmetry */
            align-items: center;
            justify-content: center;
            text-decoration: none;
            background-color: #000; /* X brand color */
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 12px 16px;
            font-size: 16px;
            cursor: pointer;
            width: 100%;            /* fill grid cell */
        }
        .brag-button:hover {
            background-color: #111;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>
    <canvas id="bg"></canvas>
    <div id="cloud-layer" aria-hidden="true"></div>
    <div class="content-card">
        <div class="main-text">418 You're a Tpot</div>
        <div class="sub-text">Go touch grass</div>
        <div class="counter-text" id="counter">Loading grass touches...</div>
        <button class="grass-button" onclick="findNearestGrass()">Go touch grass</button>
        <div class="button-row-secondary">
            <a
                class="brag-button"
                href="https://x.com/intent/tweet?text=I%20touched%20grass%20and%20bragged%20to%20Tpot"
                target="_blank" rel="noopener noreferrer"
            >Brag to TPOT that you touched grass</a>
            <a
                class="brag-button"
                href="https://x.com/i/communities/1977848352630010048"
                target="_blank" rel="noopener noreferrer"
            >Join the Movement</a>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-firestore-compat.js"></script>
    <script type="text/javascript">
        // Initialize Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyAMEJp1XSFccq00iikjqai0UoOev4NiHr4",
            authDomain: "tpot-a5a24.firebaseapp.com",
            projectId: "tpot-a5a24",
            storageBucket: "tpot-a5a24.firebasestorage.app",
            messagingSenderId: "809026922947",
            appId: "1:809026922947:web:8a62b23bee5044c80af576",
            measurementId: "G-GJBVTCXPFC"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        // Reference to counter document
        const counterRef = db.collection('counters').doc('grassCounter');

        // Update and display counter
        function updateCounter() {
            counterRef.get().then((doc) => {
                if (doc.exists) {
                    document.getElementById('counter').innerText = `TPOT has touched grass ${doc.data().count} times`;
                } else {
                    counterRef.set({ count: 0 });
                    document.getElementById('counter').innerText = 'TPOT has touched grass 0 times';
                }
            }).catch((error) => {
                console.error('Error getting counter:', error);
                document.getElementById('counter').innerText = 'Error loading counter';
            });
        }

        // Increment counter on button click
        function findNearestGrass() {
            counterRef.update({
                count: firebase.firestore.FieldValue.increment(1)
            }).then(() => {
                updateCounter();
            }).catch((error) => {
                console.error('Error updating counter:', error);
            });

            // Try to open a new tab synchronously to avoid popup blockers.
            // Write a small temporary page into it so users don't see an empty about:blank
            // while the browser prompts for geolocation permission.
            let newWin = null;
            try { newWin = window.open('', '_blank'); } catch (e) { newWin = null; }
            if (newWin && !newWin.closed) {
                try {
                    const tmpHtml = `<!doctype html><html><head><meta name="viewport" content="width=device-width,initial-scale=1"><title>Finding parks...</title><style>body{font-family:Arial,Helvetica,sans-serif;margin:0;height:100vh;display:flex;align-items:center;justify-content:center;background:#fff;color:#222} .box{padding:18px;text-align:center} .spinner{width:36px;height:36px;border:4px solid #eee;border-top-color:#333;border-radius:50%;margin:8px auto;animation:spin 1s linear infinite}@keyframes spin{to{transform:rotate(360deg)}}</style></head><body><div class="box"><div class="spinner" aria-hidden="true"></div><h2>Finding nearby parksâ€¦</h2><p>Please allow location access in your browser.</p></div></body></html>`;
                    newWin.document.open();
                    newWin.document.write(tmpHtml);
                    newWin.document.close();
                } catch (e) {
                    // writing can fail in some browsers/security contexts; ignore and continue
                }
            }

            // Prefer requesting geolocation from the new window so permission UI appears there.
            const opts = { enableHighAccuracy: false, timeout: 8000, maximumAge: 60000 };
            let geoCaller = null;
            try {
                if (newWin && !newWin.closed && newWin.navigator && newWin.navigator.geolocation) {
                    geoCaller = newWin;
                }
            } catch (e) {
                // Accessing newWin may throw if cross-origin or blocked; fall back to current window
                geoCaller = null;
            }

            if (!geoCaller && navigator.geolocation) {
                geoCaller = window;
            }

            if (geoCaller && geoCaller.navigator && geoCaller.navigator.geolocation) {
                geoCaller.navigator.geolocation.getCurrentPosition(
                    function(position) {
                        const lat = position.coords.latitude;
                        const lng = position.coords.longitude;
                        const url = `https://www.google.com/maps/search/parks/@${lat},${lng},15z`;
                        // If caller is the new window, navigate it; otherwise navigate newWin if available
                        if (geoCaller !== window) {
                            try {
                                geoCaller.location.href = url;
                                return;
                            } catch (e) {
                                // ignore and fall back
                            }
                        }
                        if (newWin && !newWin.closed) {
                            try { newWin.location.href = url; return; } catch (e) { /* fall through */ }
                        }
                        const opened = window.open(url, '_blank');
                        if (!opened) window.location.href = url;
                    },
                    function(error) {
                        if (newWin && !newWin.closed) try { newWin.close(); } catch (e) {}
                        console.warn('Geolocation failed:', error);
                        alert('Could not determine location. Opening nearby parks page instead.');
                        const fallbackUrl = 'https://www.google.com/maps/search/parks';
                        const opened = window.open(fallbackUrl, '_blank');
                        if (!opened) window.location.href = fallbackUrl;
                    },
                    opts
                );
            } else {
                // No geolocation available anywhere
                if (newWin && !newWin.closed) try { newWin.close(); } catch (e) {}
                alert('Geolocation not supported by this browser. Opening general parks search.');
                const fallbackUrl = 'https://www.google.com/maps/search/parks';
                const opened = window.open(fallbackUrl, '_blank');
                if (!opened) window.location.href = fallbackUrl;
            }
        }

        // Initial counter load
        updateCounter();
    </script>
    <script>
    // Cloud animation layer above Three.js canvas; tuned to stay high and spread out
        (function() {
            const layer = document.getElementById('cloud-layer');
            if (!layer) return;

            const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            // Dynamic speed scale for mobile to avoid fast clouds; stronger reduction
            function getSpeedScale() {
                const w = window.innerWidth || 0;
                if (prefersReduced) return 0.25;   // extra slow if reduced motion
                // scale roughly with viewport width
                if (w < 400) return 0.25;
                if (w < 480) return 0.3;
                if (w < 640) return 0.4;
                if (w < 768) return 0.5;
                if (w < 960) return 0.75;
                return 1.0; // desktop
            }
            let speedScale = getSpeedScale();
            let NUM_CLOUDS = prefersReduced ? 3 : 7;
            // Base speed ranges (unscaled)
            const BASE_CLOUD_SPEED_MIN = prefersReduced ? 5 : 15;   // px/s
            const BASE_CLOUD_SPEED_MAX = prefersReduced ? 15 : 45;  // px/s
            let SPEED_MIN = BASE_CLOUD_SPEED_MIN * speedScale;
            let SPEED_MAX = BASE_CLOUD_SPEED_MAX * speedScale;
            const MIN_GAP_BASE = 160; // minimum horizontal spacing in px
            const WIDTH_MIN = 140;
            const WIDTH_MAX = 320;
            const LANE_COUNT = 4; // vertical lanes to avoid vertical clumping
            const LANE_JITTER = 12; // px vertical jitter within a lane

            const vw = () => window.innerWidth;
            const vh = () => window.innerHeight;
            const skyTop = () => Math.round(0.00 * vh());
            const skyBottom = () => Math.round(0.12 * vh()); // very high sky band

            let laneYs = [];
            function computeLanes() {
                const top = skyTop();
                const bottom = Math.max(top + 1, skyBottom());
                const span = Math.max(1, bottom - top);
                laneYs = new Array(LANE_COUNT).fill(0).map((_, i) => Math.round(top + (i + 0.5) * (span / LANE_COUNT)));
            }
            computeLanes();

            const clouds = [];
            let plane = null; // single plane instance
            function rand(min, max) { return Math.random() * (max - min) + min; }
            function pickLane() { return Math.floor(rand(0, LANE_COUNT)); }

            function makeCloud(initial = false, i = 0) {
                const img = document.createElement('img');
                img.src = 'cloud.png';
                img.alt = '';
                img.className = 'cloud';

                // Random width
                const width = Math.round(rand(WIDTH_MIN, WIDTH_MAX));
                img.style.width = width + 'px';

                // Lane-based vertical position in the sky region
                const lane = pickLane();
                const y = (laneYs[lane] || skyTop()) + Math.round(rand(-LANE_JITTER, LANE_JITTER));

                // Starting X position, evenly phase some clouds to reduce initial crowding
                const startX = initial
                    ? Math.round(((i / NUM_CLOUDS) * (vw() + width)) - width)
                    : -width - Math.round(rand(0, vw() * 0.2));

                // Random base speed, scaled to current speedScale
                const baseSpeed = rand(BASE_CLOUD_SPEED_MIN, BASE_CLOUD_SPEED_MAX);
                const speed = baseSpeed * speedScale;

                layer.appendChild(img);
                const cloud = { el: img, x: startX, y, speed, baseSpeed, width, lane };
                img.style.transform = `translate(${cloud.x}px, ${cloud.y}px)`;
                clouds.push(cloud);
            }

            function respawn(cloud) {
                cloud.width = cloud.el.getBoundingClientRect().width || cloud.width;
                cloud.x = -cloud.width - Math.round(rand(0, vw() * 0.25));
                cloud.lane = pickLane();
                cloud.y = (laneYs[cloud.lane] || skyTop()) + Math.round(rand(-LANE_JITTER, LANE_JITTER));
                cloud.baseSpeed = rand(BASE_CLOUD_SPEED_MIN, BASE_CLOUD_SPEED_MAX);
                cloud.speed = cloud.baseSpeed * speedScale;
                // Randomly resize on respawn
                const newWidth = Math.round(rand(WIDTH_MIN, WIDTH_MAX));
                cloud.el.style.width = newWidth + 'px';
                cloud.width = newWidth;
            }

            // Initialize clouds with even x distribution to start spread out
            for (let i = 0; i < NUM_CLOUDS; i++) makeCloud(true, i);

            // Plane helpers
            function spawnPlane(initial = false) {
                if (!plane) {
                    const img = document.createElement('img');
                    img.src = 'plane.png';
                    img.alt = 'plane';
                    img.className = 'plane';
                    layer.appendChild(img);
                    plane = { el: img, x: 0, y: 0, speed: 0, width: 0, lane: 0 };
                }

                // Size and lane (between previous large and small ranges)
                const width = Math.round(rand(300, 540));
                plane.el.style.width = width + 'px';
                plane.width = width;
                plane.lane = pickLane();
                // Move plane up quite a bit relative to clouds
                plane.y = (laneYs[plane.lane] || skyTop()) + Math.round(rand(-LANE_JITTER, LANE_JITTER));
                plane.y = Math.max(0, plane.y - Math.round(0.06 * vh()));

                // Speed (faster than clouds)
                // Base plane speed (unscaled), then apply scale
                const BASE_PLANE_MIN = prefersReduced ? 25 : 70;
                const BASE_PLANE_MAX = prefersReduced ? 60 : 130;
                const base = rand(BASE_PLANE_MIN, BASE_PLANE_MAX);
                plane.baseSpeed = base;
                plane.speed = base * speedScale;

                // Start X
                plane.x = initial
                    ? Math.round(rand(-plane.width, vw() * 0.5))
                    : -plane.width - Math.round(rand(20, vw() * 0.25));

                plane.el.style.transform = `translate(${Math.round(plane.x)}px, ${plane.y}px)`;
            }

            spawnPlane(true);

            let last = performance.now();
            function tick(now) {
                const dt = Math.min(0.05, (now - last) / 1000); // cap delta to avoid jumps
                last = now;
                const width = vw();

                // Move and wrap
                for (const c of clouds) {
                    c.x += c.speed * dt;
                    if (c.x > width + c.width) {
                        respawn(c);
                    }
                }

                // Move plane and wrap (only one plane on screen)
                if (plane) {
                    plane.x += plane.speed * dt;
                    if (plane.x > width + plane.width) {
                        spawnPlane(false);
                    }
                }

                // Horizontal spacing pass to reduce clumping
                const sorted = clouds.slice().sort((a, b) => a.x - b.x);
                for (let i = 1; i < sorted.length; i++) {
                    const prev = sorted[i - 1];
                    const cur = sorted[i];
                    const minGap = Math.max(MIN_GAP_BASE, 0.6 * (prev.width + cur.width));
                    const target = prev.x + minGap;
                    if (cur.x < target) {
                        const overlap = target - cur.x;
                        // Gentle push to avoid jumpy speed-ups; cap by per-frame distance
                        const maxNudge = (cur.speed || SPEED_MIN) * dt * 0.75; // at most 75% of its own frame step
                        const nudge = Math.min(overlap * 0.15, maxNudge);
                        cur.x += nudge;
                    }
                }

                // Apply transforms
                for (const c of clouds) {
                    c.el.style.transform = `translate(${Math.round(c.x)}px, ${c.y}px)`;
                }
                if (plane) {
                    plane.el.style.transform = `translate(${Math.round(plane.x)}px, ${plane.y}px)`;
                }

                requestAnimationFrame(tick);
            }
            requestAnimationFrame(tick);

            window.addEventListener('resize', () => {
                computeLanes();
                // Update speed scale and ranges on resize for responsive speeds
                speedScale = getSpeedScale();
                SPEED_MIN = BASE_CLOUD_SPEED_MIN * speedScale;
                SPEED_MAX = BASE_CLOUD_SPEED_MAX * speedScale;
                // Recompute speeds from base to avoid compounding
                for (const c of clouds) {
                    c.speed = c.baseSpeed * speedScale;
                }
                if (plane && plane.baseSpeed != null) {
                    plane.speed = plane.baseSpeed * speedScale;
                }
                // Leave current y positions; new lanes apply on next respawn
            });
        })();
    </script>
    <script type="module">
        import * as THREE from 'three';

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('bg') });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87CEEB); // Sky blue background
        renderer.shadowMap.enabled = true; // Enable shadow mapping
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows for better quality

        // Grass blade geometry: a tall thin plane with segments for bending
        const bladeWidth = 0.1;
        const bladeHeight = 1.0;
        const widthSegments = 1;
        const heightSegments = 4; // Segments allow smooth bending in shader
        const bladeGeometry = new THREE.PlaneGeometry(bladeWidth, bladeHeight, widthSegments, heightSegments);

        // Number of grass instances
        const instanceCount = 250000;

        // Custom shader material for grass with shadow support
        const grassMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0.0 },
                windStrength: { value: 0.5 },
                windSpeed: { value: 2.0 },
                shadowMap: { value: null },
                shadowMatrix: { value: new THREE.Matrix4() }
            },
            vertexShader: `
                uniform float time;
                uniform float windStrength;
                uniform float windSpeed;
                varying vec2 vUv;
                varying float vHeight;
                varying vec4 vWorldPosition;

                void main() {
                    vUv = uv;
                    vec4 localPosition = vec4(position, 1.0);

                    vec3 instancePos = instanceMatrix[3].xyz;

                    vHeight = (localPosition.y / ${bladeHeight.toFixed(1)}) + 0.5;

                    float phase = sin(time * windSpeed + instancePos.x * 0.1 + instancePos.z * 0.1);
                    float bendAmount = phase * windStrength * vHeight * vHeight;

                    localPosition.x += bendAmount * 0.5;
                    localPosition.z += bendAmount * 0.3 * cos(time * windSpeed * 0.5 + instancePos.z * 0.05);

                    vWorldPosition = modelMatrix * instanceMatrix * localPosition;

                    gl_Position = projectionMatrix * viewMatrix * vWorldPosition;
                }
            `,
            fragmentShader: `
                varying vec2 vUv;
                varying float vHeight;
                varying vec4 vWorldPosition;

                void main() {
                    vec3 baseColor = vec3(0.15, 0.5, 0.15);
                    vec3 tipColor = vec3(0.4, 0.8, 0.3);
                    vec3 color = mix(baseColor, tipColor, vHeight);

                    float alpha = smoothstep(0.0, 0.1, abs(vUv.x - 0.5)) * 0.2 + 0.8;

                    vec3 lightDir = normalize(vec3(0.0, 1.0, -1.0));
                    vec3 normal = vec3(0.0, 1.0, 0.0);
                    float diffuse = max(dot(normal, lightDir), 0.0);
                    color *= diffuse * 0.8 + 0.2;

                    gl_FragColor = vec4(color, alpha);
                }
            `,
            side: THREE.DoubleSide,
            transparent: true,
            depthWrite: false,
        });

        // Create instanced grass mesh
        const instancedGrass = new THREE.InstancedMesh(bladeGeometry, grassMaterial, instanceCount);
        instancedGrass.castShadow = true;
        instancedGrass.receiveShadow = true;
        scene.add(instancedGrass);

        // Position grass instances on a large grid to fill the view
        const fieldSize = 100; // Large field to cover background
        const dummy = new THREE.Object3D();
        for (let i = 0; i < instanceCount; i++) {
            const row = Math.floor(i / Math.sqrt(instanceCount));
            const col = i % Math.sqrt(instanceCount);
            dummy.position.set(
                (col / Math.sqrt(instanceCount) - 0.5) * fieldSize + (Math.random() - 0.5) * 1.0,
                0,
                (row / Math.sqrt(instanceCount) - 0.5) * fieldSize + (Math.random() - 0.5) * 1.0
            );
            dummy.rotation.y = Math.random() * Math.PI * 2;
            const scale = 0.8 + Math.random() * 0.4;
            dummy.scale.set(1, scale, 1);
            dummy.updateMatrix();
            instancedGrass.setMatrixAt(i, dummy.matrix);
        }
        instancedGrass.instanceMatrix.needsUpdate = true;

        // Add brown ground plane
        const groundGeometry = new THREE.PlaneGeometry(fieldSize, fieldSize);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.01;
        ground.receiveShadow = true;
        scene.add(ground);

        // Sun setup: glowing sphere with halo and shadow casting
        const sunGeometry = new THREE.SphereGeometry(1, 32, 32);
        const sunMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFF00, emissive: 0xFFFF00, emissiveIntensity: 1 });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(20, 20, -20);
        scene.add(sun);

        const haloGeometry = new THREE.PlaneGeometry(5, 5);
        const haloMaterial = new THREE.ShaderMaterial({
            uniforms: { time: { value: 0.0 }, sunColor: { value: new THREE.Vector3(1.0, 1.0, 0.0) } },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
            fragmentShader: `uniform float time; uniform vec3 sunColor; varying vec2 vUv; void main() { vec2 uv = vUv * 2.0 - 1.0; float dist = length(uv); float alpha = smoothstep(0.8, 0.2, dist) * 0.5; gl_FragColor = vec4(sunColor, alpha); }`,
            transparent: true,
            side: THREE.DoubleSide,
        });
        const halo = new THREE.Mesh(haloGeometry, haloMaterial);
        halo.position.copy(sun.position);
        halo.lookAt(camera.position);
        scene.add(halo);

        // Lighting with shadow casting
        const ambientLight = new THREE.AmbientLight(0x404040, 1.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xFFFF99, 0.9);
        directionalLight.position.copy(sun.position);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        scene.add(directionalLight);

        // Camera position
        camera.position.set(0, 5, 20);
        camera.lookAt(0, 0, 0);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate(time) {
            requestAnimationFrame(animate);
            grassMaterial.uniforms.time.value = time * 0.001;
            haloMaterial.uniforms.time.value = time * 0.001;
            renderer.render(scene, camera);
        }
        animate(0);
    </script>
</body>
</html>